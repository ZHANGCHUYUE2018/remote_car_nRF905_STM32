#include "main.h"
#include "stm32f1xx_hal.h"
#include "cmsis_os.h"

#include <stdlib.h>
#include <string.h>

extern osThreadId nRFxxxHandlerHandle;
extern osTimerId nCarStatusHandle;
extern SPI_HandleTypeDef hspi1;
extern osMutexId nRFxxxOccupyHandle;
extern osSemaphoreId nRFxxxSPIDMACpltHandle;
extern osSemaphoreId DataReadySetHandle;

#define NRFxxx_SPI_CHN							hspi1
#define NRFxxx_POWER							3

#define NRFxxx_TX_ADDR_LEN						4
#define NRFxxx_RX_ADDR_LEN						4
#define MAX_HOPPING_RETRY_TIMES					3
#define TEST_NRFxxx_TX_ADDR						0x12345678
#define TEST_NRFxxx_RX_ADDR						0x87654321

/* Here is how the RF works:
 * UP keeps monitoring if there is any valid frame available (CD should be SET) on certain channel for certain time.
 * If yes, receive frame and continuously monitoring on this channel. If no, hop to next channel according to the hopping table.
 *
 * Down keeps transmitting frames every certain ms. If transmitting failed, (can not get valid response) down start hopping procedure.
 * Hopping procedure is to trying burst transmitting ACK frame continuously.
 * If transmitting failed, jump to next channel according to table and start to transmit again.
 * The TX&RX address is generated by some algorithm and is set at start up or during hopping
 *
 */
#ifdef NRF905_AS_RF
#define NRFxxx_RX_PAYLOAD_LEN					16
#define NRFxxx_TX_PAYLOAD_LEN					NRFxxx_RX_PAYLOAD_LEN
#define NRFxxx_SPI_TX_RX_MAX_LEN				(NRFxxx_RX_PAYLOAD_LEN + 1)

#define NRFxxx_RX_ADDRESS_IN_CR					5
#define NRFxxx_CMD_WC_MASK						0x0F
#define NRFxxx_CMD_WC(unWR_CFG_ByteIndex)		((unWR_CFG_ByteIndex) & NRFxxx_CMD_WC_MASK)	// Write Configuration register
#define NRFxxx_CMD_RC_MASK						0x0F
#define NRFxxx_CMD_RC(unRD_CFG_ByteIndex)		(((unRD_CFG_ByteIndex) & NRFxxx_CMD_RC_MASK) | 0x10)	// Read Configuration register
#define NRFxxx_CMD_WTP							0x20
#define NRFxxx_CMD_RTP							0x21
#define NRFxxx_CMD_WTA							0x22
#define NRFxxx_CMD_RTA							0x23
#define NRFxxx_CMD_RRP							0x24
#define NRFxxx_CMD_CC(unPwrChn)					((unPwrChn) | 0x8000)
#define CH_MSK_IN_CC_REG						0x01FF
#define NRFxxx_DR_IN_STATUS_REG(status)			((status) & (0x01 << 5))

#define NRFxxx_HOPPING_WAIT_RX_TIME				50
#define NRFxxx_TX_WAIT_RESP_TIME				50

#else

#define NRFxxx_RX_PAYLOAD_LEN					32
#define NRFxxx_TX_PAYLOAD_LEN					NRFxxx_RX_PAYLOAD_LEN
#define NRFxxx_SPI_TX_RX_MAX_LEN				(NRFxxx_RX_PAYLOAD_LEN + 1)

#define NRFxxx_TX_ADDRESS_IN_CR					0x10
#define NRFxxx_RX_ADDRESS_IN_CR					0x0A
#define NRFxxx_RF_CH_ADDR_IN_CR					0x05
#define NRFxxx_STATUS_ADDR_IN_CR				0x07
#define NRFxxx_CMD_WC_MASK						0x1F
#define NRFxxx_CMD_WC(unWR_CFG_ByteIndex)		(((unWR_CFG_ByteIndex) & NRFxxx_CMD_WC_MASK) | 0x20)	// Write Configuration register
#define NRFxxx_CMD_RC_MASK						0x1F
#define NRFxxx_CMD_RC(unRD_CFG_ByteIndex)		((unRD_CFG_ByteIndex) & NRFxxx_CMD_RC_MASK)
#define NRFxxx_CMD_WTP							0xA0
#define NRFxxx_CMD_WAP							0xA8
#define NRFxxx_CMD_RRP							0x61
#define NRFxxx_CMD_RRPW							0x60
#define NRFxxx_CMD_FLUSH_RX_FIFO				0xE2	// flush RX FIFO
#define NRFxxx_CMD_FLUSH_TX_FIFO				0xE1	// flush TX FIFO
#define NRFxxx_DR_IN_STATUS_REG(status)			((status) & (0x01 << 6))

#define NRFxxx_HOPPING_WAIT_RX_TIME				10
#define NRFxxx_TX_WAIT_RESP_TIME				20

#endif

#define GET_LENGTH_OF_ARRAY(x) 					(sizeof(x)/sizeof(x[0]))
typedef enum _nRFxxxCommand {
	NRFxxx_CMD_GET_STATUS = 0,
	NRFxxx_CMD_SET_STATUS,
	NRFxxx_CMD_MAX
} nRFxxxCMD_t;

typedef struct _CarStatus {
	int16_t nFrontSpeed;
	int16_t nRearSpeed;
	int16_t nSteer;
} CarStatus_t;
static CarStatus_t tRemoteCarStatus;

typedef enum _nRFxxxModes {
	NRFxxx_MODE_PWR_DOWN = 0,
	NRFxxx_MODE_STD_BY,
	NRFxxx_MODE_BURST_RX,
	NRFxxx_MODE_BURST_TX,
	NRFxxx_MODE_MAX
} nRFxxxMode_t;

#ifdef NRF905_AS_RF
typedef struct _nRFxxxPinLevelInMode {
	GPIO_PinState nPWR_UP_PIN;
	GPIO_PinState nTRX_CE_PIN;
	GPIO_PinState nTX_EN_PIN;
} nRFxxxPinLevelInMode_t;
#else
typedef struct _nRFxxxPinLevelInMode {
	GPIO_PinState nTRX_CE_PIN;
} nRFxxxPinLevelInMode_t;
#endif

#ifdef NRF905_AS_RF
// Pin status according to each nRFxxx mode
static const nRFxxxPinLevelInMode_t unNRFxxxMODE_PIN_LEVEL[] = {
		{ GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET},
		{ GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET },
		{ GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET },
		{ GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET } };
// MSB of CH_NO will always be 0
static const uint8_t NRFxxx_CR_DEFAULT[] = { 0x4C, 0x0C, // F=(422.4+(0x6C<<1)/10)*1; No retransmission; +6db; NOT reduce receive power
		(NRFxxx_RX_ADDR_LEN << 4) | NRFxxx_TX_ADDR_LEN,	// 4 bytes RX & TX address;
		NRFxxx_RX_PAYLOAD_LEN, NRFxxx_TX_PAYLOAD_LEN, // 16 bytes RX & TX package length;
		0x00, 0x0C, 0x40, 0x08,	// RX address is the calculation result of CH_NO
		0x58 };	// 16MHz crystal; enable CRC; CRC16

static const uint16_t unCAR_REMOTE_HOPPING_TAB[] = { 0x804C, 0x803A, 0x8046, 0x8032, 0x804A, 0x8035,
		0x804B, 0x8037, 0x804F, 0x803E, 0x8047, 0x8038, 0x8044, 0x8034, 0x8043, 0x8034, 0x804B,
		0x8039, 0x804D, 0x803A, 0x804E, 0x803C, 0x8032, 0x803F };
#else
static const nRFxxxPinLevelInMode_t unNRFxxxMODE_PIN_LEVEL[] = { { GPIO_PIN_RESET },
	{ GPIO_PIN_RESET }, { GPIO_PIN_SET }, { GPIO_PIN_SET }};
//static const unsigned char unNRFxxxMODE_REG[] = {
//		0x3C, 0x3E, 0x3F, 0x3E
//};
static const unsigned char unCAR_REMOTE_HOPPING_TAB[] = { 0x10, 0x20, 0x12, 0x30, 0x14, 0x40,
		0x16, 0x50, 0x18, 0x22, 0x1A, 0x32, 0x1C, 0x34, 0x24, 0x36, 0x26,
		0x38, 0x28, 0x3A, 0x2A, 0x3C, 0x42, 0x46 };

typedef struct _nRFxxxInitCR {
	unsigned char unCRAddress;
	unsigned char unCRValues;
}nRFxxxInitCR_t;
//static const nRFxxxInitCR_t NRFxxx_CR_DEFAULT[] = {{1, 0x01},
//		{2, 0x01}, {4, 0x1A}, {5, 40}, {6, 0x0F}, {0, 0x3E}};
static const nRFxxxInitCR_t NRFxxx_CR_DEFAULT[] = {{0, 0x5E}, {1, 0x01},
		{2, 0x01}, {3, 0x02}, {4, 0x14}, {5, 40}, {6, 0x0F}, {7, 0x70},
		{28, 0x01}, {29, 0x06}};
#endif

typedef struct _nRFxxxStatus {
	uint32_t unNRFxxxRecvFrameCNT;
	uint32_t unNRFxxxSendFrameCNT;
	uint32_t unNRFxxxHoppingCNT;
	uint32_t unNRFxxxTxAddr;
	uint32_t unNRFxxxRxAddr;
	nRFxxxMode_t tNRFxxxCurrentMode;
	#ifdef NRF905_AS_RF
	uint16_t unNRFxxxCHN_PWR;
	#else
	uint8_t unNRFxxxCHN;
	#endif
}nRFxxxStatus_t;

static nRFxxxStatus_t tNRFxxxStatus = {0, 0, 0, 0, 0, NRFxxx_MODE_PWR_DOWN};

static int32_t setNRFxxxMode(nRFxxxMode_t tNRFxxxMode) {
	if (tNRFxxxMode >= NRFxxx_MODE_MAX){
		return (-1);
	}
	if (tNRFxxxMode == tNRFxxxStatus.tNRFxxxCurrentMode){
		return 0;
	}
	#ifdef NRF905_AS_RF
	HAL_GPIO_WritePin(NRFxxx_PWR_UP_GPIO_Port, NRFxxx_PWR_UP_Pin, unNRFxxxMODE_PIN_LEVEL[tNRFxxxMode].nPWR_UP_PIN);
	HAL_GPIO_WritePin(NRFxxx_TX_EN_GPIO_Port, NRFxxx_TX_EN_Pin, unNRFxxxMODE_PIN_LEVEL[tNRFxxxMode].nTX_EN_PIN);
	#endif
	HAL_GPIO_WritePin(NRFxxx_TRX_CE_GPIO_Port, NRFxxx_TRX_CE_Pin, unNRFxxxMODE_PIN_LEVEL[tNRFxxxMode].nTRX_CE_PIN);
	
	tNRFxxxStatus.tNRFxxxCurrentMode = tNRFxxxMode;

	return 0;
}

void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi) {
	if (&hspi1 == hspi) {
		osSemaphoreRelease(nRFxxxSPIDMACpltHandle);
	}
}

static int32_t nRFxxxSPIDataRW(SPI_HandleTypeDef* pSPI_Handler, uint8_t* pTxBuff, uint8_t* pRxBuff, uint8_t unBuffLen) {
	int32_t nWaitResult;
	nRFxxxMode_t tPreMode;
	if (unBuffLen > NRFxxx_SPI_TX_RX_MAX_LEN) {
		return (-1);
	}
	tPreMode = tNRFxxxStatus.tNRFxxxCurrentMode;
	setNRFxxxMode(NRFxxx_MODE_STD_BY);
	HAL_GPIO_WritePin(NRFxxx_CSN_GPIO_Port, NRFxxx_CSN_Pin, GPIO_PIN_RESET);
	if (HAL_OK == HAL_SPI_TransmitReceive_DMA(pSPI_Handler, pTxBuff, pRxBuff, unBuffLen)) {
		nWaitResult = osSemaphoreWait( nRFxxxSPIDMACpltHandle, 50 );
		HAL_GPIO_WritePin(NRFxxx_CSN_GPIO_Port, NRFxxx_CSN_Pin, GPIO_PIN_SET);
		setNRFxxxMode(tPreMode);
		if( nWaitResult == osOK ) {
			/* The transmission ended as expected. */
			return 0;
		} else {
			/* The call to ulTaskNotifyTake() timed out. */
			return (-1);
		}
	} else {
		return (-1);
	}
}

static int32_t nRFxxxSPIWrite(uint8_t unCMD, const uint8_t *pData, int32_t nDataLen) {
	static uint8_t unTxBuff[NRFxxx_SPI_TX_RX_MAX_LEN];
	static uint8_t unRxBuff[NRFxxx_SPI_TX_RX_MAX_LEN];
	if (nDataLen > (NRFxxx_SPI_TX_RX_MAX_LEN - 1)) {
		return (-1);
	} else {
		unTxBuff[0] = unCMD;
		if (nDataLen > 0) {
			memcpy(unTxBuff + 1, pData, nDataLen);
		}	
		return nRFxxxSPIDataRW(&NRFxxx_SPI_CHN, unTxBuff, unRxBuff, nDataLen + 1);
	}
}

static int32_t nRFxxxSPIRead(uint8_t unCMD, uint8_t *pData, int32_t nDataLen) {
	static uint8_t unTxBuff[NRFxxx_SPI_TX_RX_MAX_LEN];
	static uint8_t unRxBuff[NRFxxx_SPI_TX_RX_MAX_LEN];
	int32_t nRslt;
	if (nDataLen > (NRFxxx_SPI_TX_RX_MAX_LEN - 1)) {
		return (-1);
	} else {
		unTxBuff[0] = unCMD;
		nRslt = nRFxxxSPIDataRW(&NRFxxx_SPI_CHN, unTxBuff, unRxBuff, nDataLen + 1);
		if (0 == nRslt) {
			memcpy(pData, unRxBuff + 1, nDataLen);
		}
		return nRslt;
	}
}

static int32_t readRxPayload(uint8_t* pBuff, int32_t nBuffLen) {
	return nRFxxxSPIRead(NRFxxx_CMD_RRP, pBuff, nBuffLen);
}

static int32_t readConfig(uint8_t unConfigAddr, uint8_t* pBuff, int32_t nBuffLen) {
	return nRFxxxSPIRead(NRFxxx_CMD_RC(unConfigAddr), pBuff, nBuffLen);
}

static int readStatusReg(void) {
	int nResult;
	nRFxxxMode_t tPreMode;
	unsigned char unStatus;

	tPreMode = tNRFxxxStatus.tNRFxxxCurrentMode;
	setNRFxxxMode(NRFxxx_MODE_STD_BY);
	nResult = nRFxxxSPIRead(NRFxxx_CMD_RC(1), &unStatus, sizeof(unStatus));
	setNRFxxxMode(tPreMode);
	if (0 <= nResult) {
		return unStatus;
	} else {
		return (-1);
	}
}

static int32_t writeConfig(uint8_t unConfigAddr, const uint8_t* pBuff, int32_t nBuffLen) {
	return nRFxxxSPIWrite(NRFxxx_CMD_WC(unConfigAddr), pBuff, nBuffLen);
}

static int32_t writeTxAddr(uint32_t unTxAddr) {
	#ifdef NRF905_AS_RF
	return nRFxxxSPIWrite(NRFxxx_CMD_WTA, (uint8_t*)(&unTxAddr), sizeof(unTxAddr));
	#else
	return writeConfig(NRFxxx_TX_ADDRESS_IN_CR, (unsigned char*)(&unTxAddr), sizeof(unTxAddr));
	#endif
}

static int32_t writeRxAddr(uint32_t unRxAddr) {
	#ifdef NRF905_AS_RF
	return nRFxxxSPIWrite(NRFxxx_RX_ADDRESS_IN_CR, (uint8_t*)(&unRxAddr), sizeof(unRxAddr));
	#else
	return writeConfig(NRFxxx_RX_ADDRESS_IN_CR, (unsigned char*)(&unRxAddr), sizeof(unRxAddr));
	#endif
}

// TX and RX address are already configured during hopping
static int32_t writeTxPayload(uint8_t* pBuff, int32_t nBuffLen) {
	return nRFxxxSPIWrite(NRFxxx_CMD_WTP, pBuff, nBuffLen);
}

#define GET_CHN_PWR_FAST_CONFIG(x, y) 		((x) | ((y) << 10))
#define GET_TX_ADDR_FROM_CHN_PWR(x)			(((x) | ((x) << 16)) & 0x5CA259AA)
#define GET_RX_ADDR_FROM_CHN_PWR(x)			(((x) | ((x) << 16)) & 0xA33D59AA)

#ifdef NRF905_AS_RF
static int32_t writeFastConfig(uint16_t unPA_PLL_CHN) {
	uint8_t unSubCmd = (uint8_t)(unPA_PLL_CHN & 0xFF);
	return nRFxxxSPIWrite(NRFxxx_CMD_CC((uint8_t)(unPA_PLL_CHN >> 8)), &unSubCmd, 1);
}

#define SAME_TX_RX_CODE_IN_HOPPING_AND_SEND_FRAME		writeTxPayload(pTxBuff, nTxBuffLen); \
	setNRFxxxMode(NRFxxx_MODE_BURST_TX); \
	tNRFxxxStatus.unNRFxxxSendFrameCNT++; \
	osDelay(2); \
	setNRFxxxMode(NRFxxx_MODE_BURST_RX); \
	nWaitResult = osSemaphoreWait( DataReadySetHandle, NRFxxx_TX_WAIT_RESP_TIME ); \
	setNRFxxxMode(NRFxxx_MODE_STD_BY); \
	if( nWaitResult == osOK ) { \
		/* Something received. */
		readRxPayload(pRxBuff, nRxBuffLen); \
		setNRFxxxMode(tPreMode); \
		tNRFxxxStatus.unNRFxxxRecvFrameCNT++; \
		
static int32_t roamNRFxxx(uint8_t* pTxBuff, int32_t nTxBuffLen, uint8_t* pRxBuff, int32_t nRxBuffLen) {
	uint8_t nHoppingTimes;
	uint8_t nHoppingIndex;
	int32_t nWaitResult;
	nRFxxxMode_t tPreMode = tNRFxxxStatus.tNRFxxxCurrentMode;
	
	for (nHoppingTimes = 0; nHoppingTimes < MAX_HOPPING_RETRY_TIMES; nHoppingTimes++) {
		for (nHoppingIndex = 0; nHoppingIndex < GET_LENGTH_OF_ARRAY(unCAR_REMOTE_HOPPING_TAB); nHoppingIndex++) {
			setNRFxxxMode(NRFxxx_MODE_STD_BY);
			tNRFxxxStatus.unNRFxxxCHN_PWR = GET_CHN_PWR_FAST_CONFIG(unCAR_REMOTE_HOPPING_TAB[nHoppingIndex], NRFxxx_POWER);		
			tNRFxxxStatus.unNRFxxxTxAddr = GET_TX_ADDR_FROM_CHN_PWR(tNRFxxxStatus.unNRFxxxCHN_PWR);
			tNRFxxxStatus.unNRFxxxRxAddr = GET_RX_ADDR_FROM_CHN_PWR(tNRFxxxStatus.unNRFxxxCHN_PWR);		
			writeFastConfig(tNRFxxxStatus.unNRFxxxCHN_PWR);
			tNRFxxxStatus.unNRFxxxHoppingCNT++;
			writeTxAddr(tNRFxxxStatus.unNRFxxxTxAddr);
			writeRxAddr(tNRFxxxStatus.unNRFxxxRxAddr);
			// since in send frame and roaming a lot code is the same, use one define to replace them
			SAME_TX_RX_CODE_IN_HOPPING_AND_SEND_FRAME
				return 0;
			} else {
				
				// Continue retry
			}
		}
	}
	setNRFxxxMode(tPreMode);
	return (-1);
}

int32_t nRFxxxSendFrame(uint8_t* pTxBuff, int32_t nTxBuffLen, uint8_t* pRxBuff, int32_t nRxBuffLen) {
	int32_t nWaitResult;
	nRFxxxMode_t tPreMode;
	int32_t nResult;
	
	if (osMutexWait(nRFxxxOccupyHandle, 500) != osOK) {
		return (-1);
	}
	tPreMode = tNRFxxxStatus.tNRFxxxCurrentMode;

	// since in send frame and roaming a lot code is the same, use one define to replace them
	SAME_TX_RX_CODE_IN_HOPPING_AND_SEND_FRAME
		osMutexRelease(nRFxxxOccupyHandle);
		return 0;
	} else {
		/* The call to ulTaskNotifyTake() timed out. */
		nResult = roamNRFxxx(pTxBuff, nTxBuffLen, pRxBuff, nRxBuffLen);
		setNRFxxxMode(tPreMode);
		osMutexRelease(nRFxxxOccupyHandle);
		return nResult;
	}
}
#else
static int readRxPayloadWidth(void) {
	unsigned char unReadBuff;
	nRFxxxMode_t tPreMode;

	tPreMode = tNRFxxxStatus.tNRFxxxCurrentMode;
	setNRFxxxMode(NRFxxx_MODE_STD_BY);
	if (nRFxxxSPIRead(NRFxxx_CMD_RRPW, &unReadBuff, sizeof(unReadBuff)) > 0) {
		setNRFxxxMode(tPreMode);
		return unReadBuff;
	} else {
		setNRFxxxMode(tPreMode);
		return (-1);
	}
}
static int clearDRFlag(void) {
	static const uint8_t unClearDRFlag = 0x70;
	return writeConfig(NRFxxx_STATUS_ADDR_IN_CR, &unClearDRFlag, 1);
}

static int32_t roamNRFxxx(uint8_t* pTxBuff, int32_t nTxBuffLen, uint8_t* pRxBuff, int32_t nRxBuffLen) {
	uint8_t nHoppingTimes;
	uint8_t nHoppingIndex;
	int32_t nWaitResult;
	nRFxxxMode_t tPreMode = tNRFxxxStatus.tNRFxxxCurrentMode;
	
	for (nHoppingTimes = 0; nHoppingTimes < MAX_HOPPING_RETRY_TIMES; nHoppingTimes++) {
		for (nHoppingIndex = 0; nHoppingIndex < GET_LENGTH_OF_ARRAY(unCAR_REMOTE_HOPPING_TAB); nHoppingIndex++) {
			setNRFxxxMode(NRFxxx_MODE_STD_BY);

			tNRFxxxStatus.unNRFxxxCHN = GET_CHN_PWR_FAST_CONFIG(unCAR_REMOTE_HOPPING_TAB[nHoppingIndex], NRFxxx_POWER);		
			tNRFxxxStatus.unNRFxxxTxAddr = GET_TX_ADDR_FROM_CHN_PWR(tNRFxxxStatus.unNRFxxxCHN);
			tNRFxxxStatus.unNRFxxxRxAddr = GET_RX_ADDR_FROM_CHN_PWR(tNRFxxxStatus.unNRFxxxCHN);		
			writeConfig(NRFxxx_RF_CH_ADDR_IN_CR, &(tNRFxxxStatus.unNRFxxxCHN), sizeof(tNRFxxxStatus.unNRFxxxCHN));		

			tNRFxxxStatus.unNRFxxxHoppingCNT++;
			writeTxAddr(tNRFxxxStatus.unNRFxxxTxAddr);
			writeRxAddr(tNRFxxxStatus.unNRFxxxRxAddr);
			writeTxPayload(pTxBuff, nTxBuffLen);
			setNRFxxxMode(NRFxxx_MODE_BURST_TX);
			tNRFxxxStatus.unNRFxxxSendFrameCNT++;

			nWaitResult = osSemaphoreWait( DataReadySetHandle, NRFxxx_HOPPING_WAIT_RX_TIME );
			if( nWaitResult == osOK ) {
				/* Something received. */
				clearDRFlag();
				readRxPayload(pRxBuff, nRxBuffLen);
				setNRFxxxMode(tPreMode);
				tNRFxxxStatus.unNRFxxxRecvFrameCNT++;
				return 0;
			} else {
				
				// Continue retry
			}
		}
	}
	setNRFxxxMode(tPreMode);
	return (-1);
}

int32_t nRFxxxSendFrame(uint8_t* pTxBuff, int32_t nTxBuffLen, uint8_t* pRxBuff, int32_t nRxBuffLen) {
	int32_t nWaitResult;
	nRFxxxMode_t tPreMode;
	int32_t nResult, nStatusReg, nRxPayloadWidth;
	
	if (osMutexWait(nRFxxxOccupyHandle, 500) != osOK) {
		return (-1);
	}
	tPreMode = tNRFxxxStatus.tNRFxxxCurrentMode;

	nRFxxxSPIWrite(NRFxxx_CMD_FLUSH_TX_FIFO, NULL, 0);
	writeTxPayload(pTxBuff, nTxBuffLen);
	setNRFxxxMode(NRFxxx_MODE_BURST_TX);
	tNRFxxxStatus.unNRFxxxSendFrameCNT++;

	nWaitResult = osSemaphoreWait( DataReadySetHandle, NRFxxx_TX_WAIT_RESP_TIME );
	setNRFxxxMode(NRFxxx_MODE_STD_BY);
	if( nWaitResult == osOK ) {
		tNRFxxxStatus.unNRFxxxRecvFrameCNT++;
		/* Something received. */
		nStatusReg = readStatusReg();
		if ((nStatusReg >= 0) && (NRFxxx_DR_IN_STATUS_REG(nStatusReg) != 0)) {
			nRxPayloadWidth = readRxPayloadWidth();
			if ((nRxPayloadWidth > 0) && (nRxPayloadWidth <= 32)) {
				readRxPayload(pRxBuff, nRxBuffLen);
			}
		}
		nRFxxxSPIWrite(NRFxxx_CMD_FLUSH_RX_FIFO, NULL, 0);
		clearDRFlag();
		setNRFxxxMode(tPreMode);
		osMutexRelease(nRFxxxOccupyHandle);
		return 0;
	} else {
		/* The call to ulTaskNotifyTake() timed out. */
		//nResult = roamNRFxxx(pTxBuff, nTxBuffLen, pRxBuff, nRxBuffLen);
		nRFxxxSPIWrite(NRFxxx_CMD_FLUSH_RX_FIFO, NULL, 0);
		clearDRFlag();
		setNRFxxxMode(tPreMode);
		osMutexRelease(nRFxxxOccupyHandle);
		return nResult;
	}
}
#endif

int32_t nRFxxxDataReadyHandler(void) {
	osSemaphoreRelease(DataReadySetHandle);
	return 0;
}

static int32_t nRFxxxCRInitial(void) {
	#ifdef NRF905_AS_RF
	return writeConfig(0, NRFxxx_CR_DEFAULT, sizeof(NRFxxx_CR_DEFAULT));
	#else
	uint8_t i;
	writeTxAddr(0x12345678);
	writeRxAddr(0x12345678);
	for (i = 0; i < GET_LENGTH_OF_ARRAY(NRFxxx_CR_DEFAULT); i++) {
		if (writeConfig(NRFxxx_CR_DEFAULT[i].unCRAddress,
				&(NRFxxx_CR_DEFAULT[i].unCRValues), 1) < 0) {
			return (-1);
		}
	}

	return 0;
	#endif	
}

uint32_t unSysTickTest;
void queryCarStatus(void const * argument) {
	uint32_t unSysTick;
	uint8_t unCmd[1+sizeof(unSysTick)]; 
	uint8_t unReadFrame[sizeof(CarStatus_t)];
	
	unCmd[0] = NRFxxx_CMD_GET_STATUS; 
	unSysTick = HAL_GetTick();
	memcpy(unCmd + 1, &unSysTick, sizeof(unSysTick)); 
	if (nRFxxxSendFrame(unCmd, sizeof(unCmd), unReadFrame, sizeof(unReadFrame)) == 0) {
		unSysTickTest = HAL_GetTick() - unSysTick;
		tRemoteCarStatus = *((CarStatus_t*)unReadFrame);
	} 
}

CarStatus_t getCarStatus(void) {
	return tRemoteCarStatus;
}

uint8_t unReadConfBuff[10];
static int32_t nRFxxxInitial(void) {
	uint8_t i;
	HAL_GPIO_WritePin(NRFxxx_CSN_GPIO_Port, NRFxxx_CSN_Pin, GPIO_PIN_SET);
	setNRFxxxMode(NRFxxx_MODE_STD_BY);
	osSemaphoreWait( nRFxxxSPIDMACpltHandle, 5 );
	osSemaphoreWait( DataReadySetHandle, 5 );
	osDelay(10);
	nRFxxxCRInitial();
	for (i = 0; i < GET_LENGTH_OF_ARRAY(unReadConfBuff); i++) {
		readConfig(i, unReadConfBuff + i, 1);
	}
	return 0;
}

void startNRFxxxTrans(void const * argument) {
	nRFxxxInitial();
	osTimerStart(nCarStatusHandle, 200);
	while (1) {
		osDelay(1000);
		HAL_GPIO_TogglePin(LED2_GPIO_Port, LED2_Pin);
	}
}
